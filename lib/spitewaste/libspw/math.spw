import util ; range for factorial, inc for ilog

; returns B raised to the power E
; [B E] => [B**E]
;
; [0 0] => [1],   [0 9] => [0],   [9 0] => [1]
; [3 2] => [9],   [2 3] => [8],   [7 4] => [2401]
pow: push 1 swap
_pow_loop: ; [b n e]
  dup jz _pow_done
  swap copy 2 mul ; [b e n*b]
  swap push 1 sub jump _pow_loop
_pow_done: swap slide 2 ret

; returns the product of the integers from 1 to N, with 0! defined to be 1
; [N] => [N!]
;
; [0] => [1],   [1] => [1],     [2] => [2]
; [3] => [6],   [5] => [120],   [10] => [3628800]
factorial: push 0 swap :range
_fac_loop: swap dup jz _fac_done mul jump _fac_loop

_fac_done: pop ret

; returns the integer square root of N
; [N] => [floor(sqrt(N))]
;
; [0] => [0], [1] => [1], [2] => [1], [3] => [1]
; [4] => [2], [8] => [2], [9] => [3], [99] => [9], [100] => [10]
isqrt:
  dup push 2 sub jn _isqrt_done ; nothing to do for 0 and 1
  dup push 2 div
_isqrt_loop:
  copy 1 copy 1 div copy 1 add push 2 div ; new guess is (n / g + g) / 2
  dup copy 2 sub jn _isqrt_update
  swap slide 2
_isqrt_done: ret
_isqrt_update: slide 1 jump _isqrt_loop

; returns the intger logarithm of N in base B
; ! clobbers heap address -1 TODO: maybe unnecessarily?
; [N B] => [logB(N)]
;
; [15 4] => [1], [16 4] => [2]
; [100 10] => [2]
; [42 2] => [5]
ilog: push -1,0 store ; accumulator at -1
_ilog_loop:
  swap dup jz _ilog_done
  push -1 :inc
  copy 1 div swap jump _ilog_loop
_ilog_done: push -1 load slide 2 ret

; greatest common divisor
gcd: ; [a  b]
  dup jz _gcd_done
  swap copy 1 mod
  jump gcd

_gcd_done: pop ret

; least common multiple
lcm: ; [a b]
  copy 1 mul
  swap dup copy 2 swap div
  :gcd div ret

;;;

min: ; [a b]
  copy 1 copy 1 sub jn _min_done swap
_min_done: pop ret

max: ; [a b]
  copy 1 copy 1 sub jn _max_done swap
_max_done: slide 1 ret

;;;

; -1, 0, or 1 to indicate the sign of the argument
sign: ; [n]
  dup jz _sign_zero
  jn _sign_neg
  push 1 ret
_sign_zero: ret
_sign_neg: push -1 ret

; absolute value ; [n] => [abs(n)]
abs: dup :sign mul ret

;;;

divmod:
  push -1 swap store
  dup push -1 load div
  swap push -1 load mod ret

;;;

pos?: :sign push  1 :eq ret
neg?: :sign push -1 :eq ret

;;;

divisors: ; [n]
  dup push -1 swap store ; preserve n because array operations
  :isqrt push 1 swap :range dup ; 1..n**0.5
  reject (push -1 load swap mod) :arydup ; get first half of divisors
  map (push -1 load swap div) :arycat ; map first half to second half
  push -1 load copy 2 dup mul sub jz _divisors_square
  ret

_divisors_square: slide 1 $-- ret ; de-duplicate when N is a perfect square

;;;

nCk:
  copy 1 copy 1 sub :factorial
  swap :factorial mul
  swap :factorial swap div ret
