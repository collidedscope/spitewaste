; [n] => [0|1]
prime?: ; [n]
  dup push 3 sub jn _prime_special ; special-case < 3
  dup push 2 mod jz _prime_even ; otherwise, even -> false
  push 3

_prime_loop: ; [n d]
  copy 1 copy 1 dup mul sub jn _prime_yes ; divisor > isqrt(n), n is prime
  copy 1 copy 1 mod jz _prime_no
  push 2 add jump _prime_loop

_prime_yes:
  pop dup div ret ; return 1

_prime_even:
  push 1
_prime_no:
  pop dup sub ret ; return 0

_prime_special: ; [n]
  push 2 sub jz _prime_two
  push 0 ret ; false for n < 2

_prime_two:
  push 1 ret

;;;

next_prime: push 1 add dup :prime? jz next_prime ret

;;;

; prime factorization
factor: ; [n]
  push 2 swap ; initial divisor
  push -2,0 store ; number of prime factors
_factor_loop: ; [d n]
  dup push 2 sub jn _factor_done
  jump _divisor_loop ; prevent dead code elimination :(
_divisor_loop:
  dup copy 2 :divmod jz _divisor_keep
  pop swap :next_prime swap jump _factor_loop

_divisor_keep: push -2 :inc slide 1 copy 1 swap jump _factor_loop

_factor_done: slide 1 push 3 sub load ret
